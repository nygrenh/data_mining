continue
students.courses.map(&:code)
students.courses
students.courses.combination(1).map(&:code)
students.courses.combination(1)
students.courses
student.courses
combinations
q
support(orders, "E", "O")
support(orders, "EO")
support(orders, "W")
q
support(orders, "W")
support(orders, "P")
support(orders, "O")
support(orders, "E")
support(orders, "W")
support(orders, W)
q
3/19
orders.count {|o| o.include? "W" }
orders.count
orders
support(orders, "T")
q
support(orders, "W")
support(orders, "T")
continue
support(orders, "T")
q
orders
q
sup.size
sup
q
sup.first.size
sup.first
sup.size
sup
exit
continue
combination[0].name
combination[0]
continue
combinations.first
combinations
exit
courses
continue
combinations.first
combinations
continue
students.courses.count
students.courses
continue
students.courses.count
students.courses
continue
with_all(*from).count
with_all(*from)
from
with_all(from)
with_all(from).count
from.count
from
continue
to
from
continue
to
from
from.and(to).count
from.and(to).count.to_f
from.and(to).count.to_f / from.count
q
to.count
continue
to.count
from.count
q
from.and(to).count
from.count
from.and(to).count
from.and(to)
from.count
c
all
courses
continue
courses
course
all
self
q
students | other.students
@students
other
self
students
q
@students | other.students
self | other
other
q
from
q
support.to_f / students.count
students.count
support
support / students.count
support / studens.count
students.count
students
support
